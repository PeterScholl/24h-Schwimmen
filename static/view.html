<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8" />
  <title>Ergebnisse - 24h Schwimmen</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      height: 100vh;
      background-color: #f8f8fd;
      margin: 0;
    }

    #root {
      display: flex;
      flex: 1;
    }

    .left,
    .right {
      padding: 1rem;
      overflow-y: auto;
    }

    .left {
      width: 70%;
      border-right: 1px solid #ccc;
      font-size: var(--font-size, 16px);
      scroll-behavior: smooth;
    }

    .right {
      width: 30%;
      background: #f5f5f5;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    td,
    th {
      padding: 4px;
      border-bottom: 1px solid #dddddd;
      border: 1px solid #e6eaff;
    }

    tbody tr:nth-child(odd) {
      background-color: #c7cafa;
    }

    tbody tr:nth-child(even) {
      background-color: #dde4ff;
    }

    select {
      margin-bottom: 1rem;
      padding: 0.5rem 1rem;
      border: 1px solid #ccc;
      border-radius: 20px;
      background-color: white;
      font-size: 1rem;
      appearance: none;
      background-position: right 0.75rem center;
      background-size: 1rem;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    select:focus {
      border-color: #007bff;
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }
  </style>
</head>

<body>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    // Hooks werden aus dem React bjekt geholt
    // useState: Speichert und verwaltet veränderliche Daten, die beim Rendern die UI beeinflussen
    //           (z.B. Schwimmerdaten, Filterzustand).
    // useEffect: Führt Nebenwirkungen aus, z.B. Daten laden, Timer starten, oder Scroll-Intervalle
    //            einrichten – also Code, der nicht direkt beim Rendern passiert.
    // useRef: Hält veränderliche Werte oder DOM-Referenzen, die sich ändern können, ohne ein
    //         erneutes Rendern auszulösen (z.B. Scroll-Position oder Zugriff auf das linke Container-Element).

    const { useState, useEffect, useRef } = React;
    let lastupdate = new Date("2000-01-01T00:00:00Z").toISOString();
    const offsetInMinutes = new Date().getTimezoneOffset(); // z.B. -120 für MESZ (UTC+2)
    const offsetInMillis = -offsetInMinutes * 60 * 1000;

    function gibNeueEintraege(neueListe, vorhandeneListe) {
      return neueListe.filter(neu =>
        !vorhandeneListe.some(alt =>
          alt.kommando === neu.kommando &&
          alt.parameter === neu.parameter &&
          alt.zeitstempel === neu.zeitstempel
        )
      );
    }

    function App() {
      let curSwimmerMap = {};
      let curActions = [];
      const [swimmerMap, setSwimmerMap] = useState({});
      // Referenz zum Zwischenspeichern des jeweils aktuellen swimmerMap-States
      const [filterAuswahl, setFilterAuswahl] = useState("");
      const [shiftLockAktiv, setShiftLockAktiv] = useState(false);
      const swimmerMapRef = useRef(swimmerMap);
      const [lapLog, setLapLog] = useState([]);
      const [filter, setFilter] = useState({ gruppe: null, nurKinder: false, sortierung: "bahnanzahl" });
      const leftRef = useRef();
      const scrollPosition = useRef(0);

      function downloadCSV(headers = ["nummer","vorname","nachname","bahnanzahl"]) {
        const maxID = Math.max(...Object.keys(curSwimmerMap).map(s => parseInt(s)));
        console.log("Maximum:", maxID);
        
        let csvRows = [
          "id,"+headers.join(',') // Kopfzeile
        ];

        for (let i = 0; i<maxID; i++) {
          if (curSwimmerMap[i+1]) {
          csvRows.push(`${i+1},`+
            headers.map(header => `"${(curSwimmerMap[i+1][header] ?? '').toString().replace(/"/g, '""')}"`).join(',')
          )
          } else {
           csvRows.push(`${i+1},`+
            headers.map(header => `"0"`).join(',')
          ) 
          }
        }

        const csvContent = csvRows.join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.href = url;
        link.download = "schwimmerdaten.csv";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      function updateBahnen(schwimmerID, anzahl = 1, zeit = new Date().toISOString()) {
        if (curSwimmerMap[schwimmerID]) {
          const s = { ...curSwimmerMap[schwimmerID] }
          s.bahnanzahl += anzahl;
          curSwimmerMap[schwimmerID] = s;
          setSwimmerMap({ ...curSwimmerMap });
          const newlapcount = s.bahnanzahl
          const lzeit = new Date((new Date(zeit)).getTime() + offsetInMillis);
          setLapLog((prev) => [{
            schwimmer: schwimmerID,
            zeit: lzeit.toISOString(),
            laps: newlapcount,
            vorname: s.vorname
          }, ...prev.slice(0, 19)]);
        }
        //setLapLog((prev) => [{ schwimmer: schwimmerID, zeit: zeit, laps: swimmerMapRef.current[schwimmerID].bahnanzahl }, ...prev.slice(0, 19)]);
      }

      function holeNeueDaten(since) {
        fetch('/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify([{ 'kommando': "VIEW", 'parameter': (since ? [since] : []), 'timestamp': new Date().toISOString() }])
        })
          //fetch("/api/daten") // Pfad zum Server-Endpunkt
          .then((res) => res.json())
          .then((data) => {
            if (data.swimmerMap) {
              data.swimmerMap.forEach(s => {
                //console.log("S",s);
                s.bahnanzahl = 0;
                curSwimmerMap[s.nummer] = s;
              })
              //console.log(`curSwimmerMap ist ein Array ${Array.isArray(curSwimmerMap)}`);
              //console.log("curSwimmerMap", JSON.stringify(curSwimmerMap));

              setSwimmerMap({ ...curSwimmerMap })
            }
            if (data.lapLog) setLapLog(data.lapLog);
            if (data.actions) {
              //console.log("data.actions", JSON.stringify(data.actions));
              let datasorted = data.actions.filter((x) => x.kommando == "ADD")
              datasorted.sort((a, b) => a.zeitstempel.localeCompare(b.zeitstempel)); // sortiert
              const neueElemente = gibNeueEintraege(datasorted, curActions);
              neueElemente.forEach(element => {
                // Wenn noch nicht in curActions vorhanden, einfügen
                curActions.push(element);
                // und Bahnazahl aktualisieren
                const parameter = JSON.parse(element.parameter);
                if (curSwimmerMap[parameter[0]]) {
                  if (lastupdate < element.zeitstempel) lastupdate = element.zeitstempel
                  //console.log(`Update ${parameter[0]} - ${parameter[1]}, ${element.zeitstempel}`);
                  updateBahnen(parseInt(parameter[0]), parseInt(parameter[1]), element.zeitstempel);
                } else {
                  console.log(`Schwimmer ${parameter[0]} gibt es noch nicht`);
                }

              });
            }
            if (data.filter) setFilter(data.filter);
          })
          .catch((err) => console.error("Fehler beim Laden:", err));
      }

      // Effekt: immer wenn swimmerMap sich ändert, aktualisiere die Ref
      useEffect(() => {
        swimmerMapRef.current = swimmerMap;
      }, [swimmerMap]);

      useEffect(() => {
        function handleKeyDown(e) {
          if (e.shiftKey && e.key === "L") {
            setShiftLockAktiv((prev) => !prev);
          } else if (e.shiftKey && e.key === "D") {
            console.log("Download gedrückt");
            downloadCSV();
          }
        }
        window.addEventListener("keydown", handleKeyDown);
        return () => window.removeEventListener("keydown", handleKeyDown);
      }, []);

      useEffect(() => {
        holeNeueDaten();
      }, []); // [] - sorgt dafür, dass dieser Effect (diese Funktion) nur ein einziges Mal ausgeführt wird


      /*useEffect(() => {
        const vornamen = ["Luca", "Emma", "Ben", "Mia", "Noah", "Lea", "Elias", "Lina"];
        const nachnamen = ["Schmidt", "Müller", "Weber", "Schneider", "Fischer", "Meyer", "Wagner"];
        const gruppen = ["A", "B", "C", "D"];

        const initialSwimmers = {};
        for (let i = 1; i <= 10; i++) {
          initialSwimmers[i] = {
            nummer: i,
            vorname: vornamen[Math.floor(Math.random() * vornamen.length)],
            nachname: nachnamen[Math.floor(Math.random() * nachnamen.length)],
            gruppe: gruppen[Math.floor(Math.random() * gruppen.length)],
            istKind: Math.random() < 0.3 ? 1 : 0,
            bahnanzahl: Math.floor(Math.random() * 100),
          };
        }
        setSwimmerMap(initialSwimmers);
      }, []); // [] - sorgt dafür, dass dieser Effect (diese Funktion) nur ein einziges Mal ausgeführt wird

      useEffect(() => {
        const interval = setInterval(() => {
          console.log("3 Sekunden Timer");
          const ids = Object.keys(swimmerMap);
          if (ids.length === 0) return;
          const id = ids[Math.floor(Math.random() * ids.length)];
          updateBahnen(id);
        }, 3000);
        return () => clearInterval(interval); //cleanup-Funktion, die vor erneuter Ausführung aufgerufen wird
      }, [swimmerMap]); */ // [swimmerMap] sorgt dafür, dass dies nur nach Änderungen der swimmer-Map ausgeführt wird

      // Der Timer für das holen neuer Daten
      useEffect(() => {
        const interval10 = setInterval(() => {
          const date = new Date(lastupdate);
          date.setHours(date.getHours() - 1); // Hole die Daten der letzten Stunde
          holeNeueDaten(date);
        }, 5000); // alle 5 Sekunden
        return () => clearInterval(interval10); // Aufräumen bei Komponentendemontage
      }, []);

      // Der Timer wird in Use-Effect gepackt, damit er erst nach dem ersten Rendern ausgeführt wird
      useEffect(() => {
        if (!shiftLockAktiv) return; // Nur aktivieren wenn Shift Lock aktiv

        const scrollInt = setInterval(() => {
          const container = leftRef.current;
          if (!container) return;
          scrollPosition.current += 8;
          if (scrollPosition.current >= container.scrollHeight - container.clientHeight) {
            scrollPosition.current = 0;
          }
          container.scrollTop = scrollPosition.current;
        }, 100);

        return () => clearInterval(scrollInt); // Aufräumen
      }, [shiftLockAktiv]); // Neu starten bei Änderung von shiftLockAktiv


      let gefiltert = Object.values(swimmerMap);
      if (filterAuswahl === "nurKinder") {
        gefiltert = gefiltert.filter((s) => s.istKind);
      } else if (filterAuswahl.startsWith("gruppe-")) {
        const gruppe = filterAuswahl.split("-")[1];
        gefiltert = gefiltert.filter((s) => s.gruppe === gruppe);
      }
      gefiltert.sort((a, b) => b.bahnanzahl - a.bahnanzahl);

      return (
        <div id="root">
          <div className="left" ref={leftRef}>
            <h2>Ranking</h2>
            <select value={filterAuswahl} onChange={(e) => setFilterAuswahl(e.target.value)}>
              <option value="">Alle anzeigen</option>
              <option value="nurKinder">Nur Kinder</option>
            </select>
            <table>
              <thead>
                <tr>
                  <th>#</th>
                  <th>Name</th>
                  <th>Gruppe</th>
                  <th>Bahnen</th>
                </tr>
              </thead>
              <tbody>
                {gefiltert.map((s, i) => (
                  <tr key={s.nummer}>
                    <td>{i + 1}</td>
                    <td>
                      ({s.nummer}) {s.vorname} {s.nachname}
                    </td>
                    <td>{s.gruppe}</td>
                    <td>{s.bahnanzahl}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          <div className="right">
            <h2>Letzte Bahnen</h2>
            {lapLog.map((l, i) => {
              return (
                <div key={i}>
                  {l.zeit.split("T")[1].split(".")[0]} – {l.vorname} ({l.schwimmer}) hat angeschlagen: {l.laps} Bahnen
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>

</html>